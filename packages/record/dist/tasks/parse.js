"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseDatamodel = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _sdk = require("@prisma/sdk");

var esbuild = _interopRequireWildcard(require("esbuild"));

var _paths = require("@redwoodjs/internal/dist/paths");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const DATAMODEL_PATH = _path.default.join((0, _paths.getPaths)().api.models, 'datamodel.js');

const MODELS_PATH = _path.default.join((0, _paths.getPaths)().api.src, 'models');

const MODELS_INDEX_PATH = _path.default.join(MODELS_PATH, 'index.js');

const indexLines = ['// This file is autogenerated by Redwood and will be overwitten periodically', '', "import { db } from 'src/lib/db'", "import datamodel from 'src/models/datamodel'", "import { RedwoodRecord } from '@redwoodjs/record'", '', 'RedwoodRecord.db = db', 'RedwoodRecord.schema = datamodel', ''];
const modelImports = [];
const modelRequires = {};
let datamodel; // parse datamodel and write out cache

const parseDatamodel = () => {
  (0, _sdk.getDMMF)({
    datamodelPath: (0, _paths.getPaths)().api.dbSchema
  }).then(schema => {
    datamodel = schema.datamodel;

    _fs.default.writeFileSync(DATAMODEL_PATH, esbuild.transformSync(JSON.stringify(datamodel, null, 2), {
      loader: 'json',
      format: 'cjs'
    }).code);

    console.info(`\n  Wrote ${DATAMODEL_PATH}`); // figure out what model classes are present

    const modelNames = _fs.default.readdirSync(MODELS_PATH).map(file => {
      if (file !== 'index.js' && file !== 'datamodel.js') {
        return file.split('.')[0];
      }
    }).filter(val => val);

    modelNames.forEach(modelName => {
      // which other models this model requires
      const thisModelRequires = []; // import statements

      modelImports.push(`import ${modelName} from 'src/models/${modelName}'`); // requireModel declarations

      const schemaModel = datamodel.models.find(model => model.name === modelName);

      if (schemaModel) {
        schemaModel.fields.forEach(field => {
          if (field.kind === 'object' && modelNames.includes(field.type)) {
            thisModelRequires.push(field.type);
          }
        });
        modelRequires[modelName] = thisModelRequires;
      }
    });
    modelImports.forEach(modelImport => {
      indexLines.push(modelImport);
    });
    indexLines.push('');

    for (const [name, requires] of Object.entries(modelRequires)) {
      indexLines.push(`${name}.requiredModels = [${requires.join(', ')}]`);
    }

    indexLines.push('');
    indexLines.push(`export { ${modelNames.join(', ')} }`);
    indexLines.push(''); // empty newline at end

    _fs.default.writeFileSync(MODELS_INDEX_PATH, indexLines.join('\n'));

    console.info(`  Wrote ${MODELS_INDEX_PATH}\n`);
  });
};

exports.parseDatamodel = parseDatamodel;