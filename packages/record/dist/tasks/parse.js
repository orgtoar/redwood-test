"use strict";

var _interopRequireWildcard = require("@babel/runtime-corejs3/helpers/interopRequireWildcard").default;

var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseDatamodel = void 0;

require("core-js/modules/esnext.async-iterator.filter.js");

require("core-js/modules/esnext.iterator.constructor.js");

require("core-js/modules/esnext.iterator.filter.js");

require("core-js/modules/esnext.async-iterator.map.js");

require("core-js/modules/esnext.iterator.map.js");

require("core-js/modules/esnext.async-iterator.for-each.js");

require("core-js/modules/esnext.iterator.for-each.js");

require("core-js/modules/esnext.async-iterator.find.js");

require("core-js/modules/esnext.iterator.find.js");

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _sdk = require("@prisma/sdk");

var esbuild = _interopRequireWildcard(require("esbuild"));

var _paths = require("@redwoodjs/internal/dist/paths");

const DATAMODEL_PATH = _path.default.join((0, _paths.getPaths)().api.models, 'datamodel.js');

const MODELS_PATH = _path.default.join((0, _paths.getPaths)().api.src, 'models');

const MODELS_INDEX_PATH = _path.default.join(MODELS_PATH, 'index.js');

const indexLines = ['// This file is autogenerated by Redwood and will be overwitten periodically', '', "import { db } from 'src/lib/db'", "import datamodel from 'src/models/datamodel'", "import { RedwoodRecord } from '@redwoodjs/record'", '', 'RedwoodRecord.db = db', 'RedwoodRecord.schema = datamodel', ''];
const modelImports = [];
const modelRequires = {};
let datamodel; // parse datamodel and write out cache

const parseDatamodel = () => {
  (0, _sdk.getDMMF)({
    datamodelPath: (0, _paths.getPaths)().api.dbSchema
  }).then(schema => {
    datamodel = schema.datamodel;

    _fs.default.writeFileSync(DATAMODEL_PATH, esbuild.transformSync(JSON.stringify(datamodel, null, 2), {
      loader: 'json',
      format: 'cjs'
    }).code);

    console.info(`\n  Wrote ${DATAMODEL_PATH}`); // figure out what model classes are present

    const modelNames = _fs.default.readdirSync(MODELS_PATH).map(file => {
      if (file !== 'index.js' && file !== 'datamodel.js') {
        return file.split('.')[0];
      }
    }).filter(val => val);

    modelNames.forEach(modelName => {
      // which other models this model requires
      const thisModelRequires = []; // import statements

      modelImports.push(`import ${modelName} from 'src/models/${modelName}'`); // requireModel declarations

      const schemaModel = datamodel.models.find(model => model.name === modelName);

      if (schemaModel) {
        schemaModel.fields.forEach(field => {
          if (field.kind === 'object' && modelNames.includes(field.type)) {
            thisModelRequires.push(field.type);
          }
        });
        modelRequires[modelName] = thisModelRequires;
      }
    });
    modelImports.forEach(modelImport => {
      indexLines.push(modelImport);
    });
    indexLines.push('');

    for (const [name, requires] of Object.entries(modelRequires)) {
      indexLines.push(`${name}.requiredModels = [${requires.join(', ')}]`);
    }

    indexLines.push('');
    indexLines.push(`export { ${modelNames.join(', ')} }`);
    indexLines.push(''); // empty newline at end

    _fs.default.writeFileSync(MODELS_INDEX_PATH, indexLines.join('\n'));

    console.info(`  Wrote ${MODELS_INDEX_PATH}\n`);
  });
};

exports.parseDatamodel = parseDatamodel;