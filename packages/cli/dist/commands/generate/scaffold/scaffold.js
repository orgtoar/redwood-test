"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs3/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs3/helpers/interopRequireDefault").default;
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.tasks = exports.splitPathAndModel = exports.shouldUseTailwindCSS = exports.routes = exports.handler = exports.files = exports.description = exports.command = exports.builder = void 0;
var _find = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/find"));
var _includes = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/includes"));
var _map = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/map"));
var _filter = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/filter"));
var _endsWith = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/ends-with"));
var _some = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/some"));
var _indexOf = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/index-of"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/keys"));
var _reduce = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/reduce"));
var _sort = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/sort"));
var _forEach = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/for-each"));
var _entries = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/object/entries"));
var _slice = _interopRequireDefault(require("@babel/runtime-corejs3/core-js/instance/slice"));
var _path = _interopRequireDefault(require("path"));
var _camelcase = _interopRequireDefault(require("camelcase"));
var _execa = _interopRequireDefault(require("execa"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _humanizeString = _interopRequireDefault(require("humanize-string"));
var _listr = require("listr2");
var _paramCase = require("param-case");
var _pascalcase = _interopRequireDefault(require("pascalcase"));
var _terminalLink = _interopRequireDefault(require("terminal-link"));
var _cliHelpers = require("@redwoodjs/cli-helpers");
var _generate = require("@redwoodjs/internal/dist/generate/generate");
var _projectConfig = require("@redwoodjs/project-config");
var _lib = require("../../../lib");
var _colors = _interopRequireDefault(require("../../../lib/colors"));
var _rollback = require("../../../lib/rollback");
var _rwPluralize = require("../../../lib/rwPluralize");
var _schemaHelpers = require("../../../lib/schemaHelpers");
var _helpers = require("../helpers");
var _sdl = require("../sdl/sdl");
var _service = require("../service/service");
// note a better way to do this is in https://github.com/redwoodjs/redwood/pull/3783/files
const NON_EDITABLE_COLUMNS = ['id', 'createdAt', 'updatedAt'];
// Any assets that should not trigger an overwrite error and require a --force
const SKIPPABLE_ASSETS = ['scaffold.css'];
const PACKAGE_SET = 'Set';
const getIdType = model => {
  var _context;
  return (0, _find.default)(_context = model.fields).call(_context, field => field.isId)?.type;
};
const getIdName = model => {
  var _context2;
  return (0, _find.default)(_context2 = model.fields).call(_context2, field => field.isId)?.name;
};
const filterAutoGeneratedColumnsForScaffold = column => {
  const autoGeneratedFunctions = ['now', 'autoincrement'];
  return !(column.isId || column.isUpdatedAt || (0, _includes.default)(autoGeneratedFunctions).call(autoGeneratedFunctions, column?.default?.name));
};
const getImportComponentNames = (name, scaffoldPath, nestScaffoldByModel = true) => {
  const pluralName = (0, _pascalcase.default)((0, _rwPluralize.pluralize)(name));
  const singularName = (0, _pascalcase.default)((0, _rwPluralize.singularize)(name));
  let componentPath;
  if (scaffoldPath === '') {
    componentPath = nestScaffoldByModel ? `src/components/${singularName}` : `src/components`;
  } else {
    var _context3;
    const sP = (0, _map.default)(_context3 = scaffoldPath.split('/')).call(_context3, _pascalcase.default).join('/');
    componentPath = nestScaffoldByModel ? `src/components/${sP}/${singularName}` : `src/components/${sP}`;
  }
  return {
    importComponentName: `${componentPath}/${singularName}`,
    importComponentNameCell: `${componentPath}/${singularName}Cell`,
    importComponentEditNameCell: `${componentPath}/Edit${singularName}Cell`,
    importComponentNameForm: `${componentPath}/${singularName}Form`,
    importComponentNewName: `${componentPath}/New${singularName}`,
    importComponentNames: `${componentPath}/${pluralName}`,
    importComponentNamesCell: `${componentPath}/${pluralName}Cell`,
    importLayoutNames: `src/layouts/ScaffoldLayout`
  };
};

// Includes imports from getImportComponentNames()
const getTemplateStrings = (name, scaffoldPath, nestScaffoldByModel = true) => {
  const nameVars = (0, _lib.nameVariants)(name);
  const camelScaffoldPath = (0, _camelcase.default)((0, _pascalcase.default)(scaffoldPath));
  return {
    pluralRouteName: scaffoldPath === '' ? nameVars.pluralCamelName : `${camelScaffoldPath}${nameVars.pluralPascalName}`,
    editRouteName: scaffoldPath === '' ? `edit${nameVars.singularPascalName}` : `${camelScaffoldPath}Edit${nameVars.singularPascalName}`,
    singularRouteName: scaffoldPath === '' ? nameVars.singularCamelName : `${camelScaffoldPath}${nameVars.singularPascalName}`,
    newRouteName: scaffoldPath === '' ? `new${nameVars.singularPascalName}` : `${camelScaffoldPath}New${nameVars.singularPascalName}`,
    ...getImportComponentNames(name, scaffoldPath, nestScaffoldByModel)
  };
};

// Checks whether Tailwind is installed, and if the `flag` argument is not
// already set, returns true. Otherwise just returns `flag`
const shouldUseTailwindCSS = flag => {
  if (flag === undefined) {
    return _fsExtra.default.existsSync(_path.default.join((0, _lib.getPaths)().web.config, 'tailwind.config.js'));
  } else {
    return flag;
  }
};
exports.shouldUseTailwindCSS = shouldUseTailwindCSS;
const files = async ({
  docs,
  model: name,
  path: scaffoldPath = '',
  tests = true,
  typescript = false,
  tailwind = false,
  force = false,
  nestScaffoldByModel
}) => {
  var _context4;
  const model = await (0, _schemaHelpers.getSchema)(name);
  if (typeof nestScaffoldByModel === 'undefined') {
    nestScaffoldByModel = (0, _projectConfig.getConfig)().generate.nestScaffoldByModel;
  }
  const templateStrings = getTemplateStrings(name, scaffoldPath, nestScaffoldByModel);
  const pascalScaffoldPath = scaffoldPath === '' ? scaffoldPath : (0, _map.default)(_context4 = scaffoldPath.split('/')).call(_context4, _pascalcase.default).join('/') + '/';
  return {
    ...(await componentFiles(name, pascalScaffoldPath, typescript, nestScaffoldByModel, templateStrings)),
    ...(await (0, _sdl.files)({
      ...(0, _lib.getDefaultArgs)(_sdl.builder),
      docs,
      name,
      typescript
    })),
    ...(await (0, _service.files)({
      ...(0, _lib.getDefaultArgs)(_service.builder),
      name,
      crud: true,
      relations: (0, _helpers.relationsForModel)(model),
      tests,
      typescript
    })),
    ...(await assetFiles(name, tailwind)),
    ...(await formatters(name, typescript)),
    ...(await layoutFiles(name, force, typescript, templateStrings)),
    ...(await pageFiles(name, pascalScaffoldPath, typescript, nestScaffoldByModel, templateStrings))
  };
};
exports.files = files;
const assetFiles = async (name, tailwind) => {
  let fileList = {};
  const assets = _fsExtra.default.readdirSync((0, _helpers.customOrDefaultTemplatePath)({
    side: 'web',
    generator: 'scaffold',
    templatePath: 'assets'
  }));
  for (const asset of assets) {
    // check if the asset name matches the Tailwind preference
    if (tailwind && asset.match(/tailwind/) || !tailwind && !asset.match(/tailwind/)) {
      const outputAssetName = asset.replace(/\.template/, '').replace(/\.tailwind/, '');
      const outputPath = _path.default.join((0, _lib.getPaths)().web.src, outputAssetName);

      // skip assets that already exist on disk, never worry about overwriting
      if (!(0, _includes.default)(SKIPPABLE_ASSETS).call(SKIPPABLE_ASSETS, _path.default.basename(outputPath)) || !_fsExtra.default.existsSync(outputPath)) {
        const template = await (0, _lib.generateTemplate)((0, _helpers.customOrDefaultTemplatePath)({
          side: 'web',
          generator: 'scaffold',
          templatePath: _path.default.join('assets', asset)
        }), {
          name
        });
        fileList[outputPath] = template;
      }
    }
  }
  return fileList;
};
const formatters = async (name, isTypescript) => {
  const outputPath = _path.default.join((0, _lib.getPaths)().web.src, 'lib', isTypescript ? 'formatters.tsx' : 'formatters.jsx');
  const outputPathTest = _path.default.join((0, _lib.getPaths)().web.src, 'lib', isTypescript ? 'formatters.test.tsx' : 'formatters.test.jsx');

  // skip files that already exist on disk, never worry about overwriting
  if (_fsExtra.default.existsSync(outputPath)) {
    return;
  }
  const template = await (0, _lib.generateTemplate)((0, _helpers.customOrDefaultTemplatePath)({
    side: 'web',
    generator: 'scaffold',
    templatePath: _path.default.join('lib', 'formatters.tsx.template')
  }), {
    name
  });
  const templateTest = await (0, _lib.generateTemplate)((0, _helpers.customOrDefaultTemplatePath)({
    side: 'web',
    generator: 'scaffold',
    templatePath: _path.default.join('lib', 'formatters.test.tsx.template')
  }), {
    name
  });
  return {
    [outputPath]: isTypescript ? template : await (0, _lib.transformTSToJS)(outputPath, template),
    [outputPathTest]: isTypescript ? templateTest : await (0, _lib.transformTSToJS)(outputPathTest, templateTest)
  };
};
const modelRelatedVariables = model => {
  var _context5, _context6, _context7, _context10, _context11, _context12, _context13, _context14;
  const componentMetadata = {
    Enum: {
      componentName: 'RadioField',
      defaultProp: 'defaultChecked',
      validation: () => false,
      listDisplayFunction: 'formatEnum',
      displayFunction: 'formatEnum'
    },
    EnumList: {
      componentName: 'CheckboxField',
      defaultProp: 'defaultChecked',
      validation: () => false,
      listDisplayFunction: 'formatEnum',
      displayFunction: 'formatEnum'
    },
    Boolean: {
      componentName: 'CheckboxField',
      defaultProp: 'defaultChecked',
      validation: () => false,
      listDisplayFunction: 'checkboxInputTag',
      displayFunction: 'checkboxInputTag'
    },
    DateTime: {
      componentName: 'DatetimeLocalField',
      deserializeFunction: 'formatDatetime',
      listDisplayFunction: 'timeTag',
      displayFunction: 'timeTag'
    },
    Int: {
      componentName: 'NumberField'
    },
    Json: {
      componentName: 'TextAreaField',
      validation: isRequired => `{{ valueAsJSON: true${isRequired ? ', required: true' : ''} }}`,
      displayFunction: 'jsonDisplay',
      listDisplayFunction: 'jsonTruncate',
      deserializeFunction: 'JSON.stringify'
    },
    Float: {
      validation: isRequired => `{{ valueAsNumber: true${isRequired ? ', required: true' : ''} }}`
    },
    Decimal: {
      validation: isRequired => `{{ valueAsNumber: true${isRequired ? ', required: true' : ''} }}`
    },
    default: {
      componentName: 'TextField',
      defaultProp: 'defaultValue',
      deserializeFunction: '',
      validation: '{{ required: true }}',
      displayFunction: undefined,
      listDisplayFunction: 'truncate'
    }
  };
  const relations = (0, _map.default)(_context5 = (0, _helpers.relationsForModel)(model)).call(_context5, relation => relation);
  const columns = (0, _map.default)(_context6 = (0, _filter.default)(_context7 = model.fields).call(_context7, field => field.kind !== 'object')).call(_context6, column => {
    var _context8;
    let validation;
    if (componentMetadata[column.type]?.validation) {
      validation = componentMetadata[column.type]?.validation(column?.isRequired);
    } else {
      validation = column?.isRequired ? componentMetadata.default.validation : null;
    }
    const isRelationalField = (0, _endsWith.default)(_context8 = column.name).call(_context8, 'Id') && (0, _some.default)(relations).call(relations, relation => {
      var _context9;
      return (0, _includes.default)(_context9 = column.name).call(_context9, relation);
    });
    const isRequired = column.isRequired;
    const isEnum = column.kind === 'enum';
    const isList = column.isList;
    const enumType = isEnum && isList ? 'EnumList' : 'Enum';
    const metadataKey = isEnum ? enumType : column.type;
    return {
      ...column,
      label: (0, _humanizeString.default)(column.name),
      component: componentMetadata[metadataKey]?.componentName || componentMetadata.default.componentName,
      defaultProp: componentMetadata[metadataKey]?.defaultProp || componentMetadata.default.defaultProp,
      deserializeFunction: componentMetadata[metadataKey]?.deserializeFunction || componentMetadata.default.deserializeFunction,
      validation,
      listDisplayFunction: componentMetadata[metadataKey]?.listDisplayFunction || componentMetadata.default.listDisplayFunction,
      displayFunction: componentMetadata[metadataKey]?.displayFunction || componentMetadata.default.displayFunction,
      values: column.enumValues || [],
      isList,
      isEnum,
      isRequired,
      isRelationalField
    };
  });
  const editableColumns = (0, _filter.default)(_context10 = (0, _filter.default)(columns).call(columns, column => {
    return (0, _indexOf.default)(NON_EDITABLE_COLUMNS).call(NON_EDITABLE_COLUMNS, column.name) === -1;
  })).call(_context10, filterAutoGeneratedColumnsForScaffold);
  const fieldsToImport = (0, _keys.default)((0, _reduce.default)(editableColumns).call(editableColumns, (accumulator, column) => {
    accumulator[column.component] = true;
    return accumulator;
  }, {}));
  if (!fieldsToImport.length) {
    throw new Error(`There are no editable fields in the ${model.name} model`);
  }
  const formattersImports = (0, _filter.default)(_context11 = (0, _sort.default)(_context12 = (0, _map.default)(columns).call(columns, column => column.displayFunction)).call(_context12)
  // filter out duplicates, so we only keep unique import names
  ).call(_context11, (name, index, array) => (0, _indexOf.default)(array).call(array, name) === index).join(', ');
  const listFormattersImports = (0, _filter.default)(_context13 = (0, _sort.default)(_context14 = (0, _map.default)(columns).call(columns, column => column.listDisplayFunction)).call(_context14)
  // filter out duplicates, so we only keep unique import names
  ).call(_context13, (name, index, array) => (0, _indexOf.default)(array).call(array, name) === index).join(', ');
  return {
    columns,
    fieldsToImport,
    editableColumns,
    listFormattersImports,
    formattersImports
  };
};
const layoutFiles = async (name, force, generateTypescript, templateStrings) => {
  let fileList = {};
  const layouts = _fsExtra.default.readdirSync((0, _helpers.customOrDefaultTemplatePath)({
    side: 'web',
    generator: 'scaffold',
    templatePath: 'layouts'
  }));
  for (const layout of layouts) {
    const outputLayoutName = layout.replace(/\.tsx\.template/, generateTypescript ? '.tsx' : '.jsx');
    const outputPath = _path.default.join((0, _lib.getPaths)().web.layouts, 'ScaffoldLayout', outputLayoutName);

    // Since the ScaffoldLayout is shared, don't overwrite by default
    if (!_fsExtra.default.existsSync(outputPath) || force) {
      const template = await (0, _lib.generateTemplate)((0, _helpers.customOrDefaultTemplatePath)({
        side: 'web',
        generator: 'scaffold',
        templatePath: _path.default.join('layouts', layout)
      }), {
        name,
        pascalScaffoldPath: '',
        ...templateStrings
      });
      fileList[outputPath] = generateTypescript ? template : await (0, _lib.transformTSToJS)(outputPath, template);
    }
  }
  return fileList;
};
const pageFiles = async (name, pascalScaffoldPath = '', generateTypescript, nestScaffoldByModel = true, templateStrings) => {
  const pluralName = (0, _pascalcase.default)((0, _rwPluralize.pluralize)(name));
  const singularName = (0, _pascalcase.default)((0, _rwPluralize.singularize)(name));
  const model = await (0, _schemaHelpers.getSchema)(singularName);
  const idType = getIdType(model);
  const idTsType = (0, _helpers.mapPrismaScalarToPagePropTsType)(idType);
  const idName = getIdName(model);
  let fileList = {};
  const pages = _fsExtra.default.readdirSync((0, _helpers.customOrDefaultTemplatePath)({
    side: 'web',
    generator: 'scaffold',
    templatePath: 'pages'
  }));
  for (const page of pages) {
    // Sanitize page names
    const outputPageName = page.replace(/Names/, pluralName).replace(/Name/, singularName).replace(/\.tsx\.template/, generateTypescript ? '.tsx' : '.jsx');
    const finalFolder = (nestScaffoldByModel ? singularName + '/' : '') + outputPageName.replace(/\.[jt]sx?/, '');
    const outputPath = _path.default.join((0, _lib.getPaths)().web.pages, pascalScaffoldPath, finalFolder, outputPageName);
    const template = await (0, _lib.generateTemplate)((0, _helpers.customOrDefaultTemplatePath)({
      side: 'web',
      generator: 'scaffold',
      templatePath: _path.default.join('pages', page)
    }), {
      idTsType,
      idName,
      name,
      pascalScaffoldPath,
      ...templateStrings,
      ...modelRelatedVariables(model)
    });
    fileList[outputPath] = generateTypescript ? template : await (0, _lib.transformTSToJS)(outputPath, template);
  }
  return fileList;
};
const componentFiles = async (name, pascalScaffoldPath = '', generateTypescript, nestScaffoldByModel = true, templateStrings) => {
  const pluralName = (0, _pascalcase.default)((0, _rwPluralize.pluralize)(name));
  const singularName = (0, _pascalcase.default)((0, _rwPluralize.singularize)(name));
  const model = await (0, _schemaHelpers.getSchema)(singularName);
  const idType = getIdType(model);
  const idName = getIdName(model);
  const pascalIdName = (0, _pascalcase.default)(idName);
  const intForeignKeys = (0, _helpers.intForeignKeysForModel)(model);
  let fileList = {};
  const components = _fsExtra.default.readdirSync((0, _helpers.customOrDefaultTemplatePath)({
    side: 'web',
    generator: 'scaffold',
    templatePath: 'components'
  }));
  for (const component of components) {
    const outputComponentName = component.replace(/Names/, pluralName).replace(/Name/, singularName).replace(/\.tsx\.template/, generateTypescript ? '.tsx' : '.jsx');
    const finalFolder = (nestScaffoldByModel ? singularName + '/' : '') + outputComponentName.replace(/\.[jt]sx?/, '');
    const outputPath = _path.default.join((0, _lib.getPaths)().web.components, pascalScaffoldPath, finalFolder, outputComponentName);
    const useClientDirective = (0, _projectConfig.getConfig)().experimental?.rsc?.enabled ? "'use client'\n\n" : '';
    const template = await (0, _lib.generateTemplate)((0, _helpers.customOrDefaultTemplatePath)({
      side: 'web',
      generator: 'scaffold',
      templatePath: _path.default.join('components', component)
    }), {
      name,
      idType,
      idName,
      pascalIdName,
      intForeignKeys,
      pascalScaffoldPath,
      useClientDirective,
      ...templateStrings,
      ...modelRelatedVariables(model)
    });
    fileList[outputPath] = generateTypescript ? template : await (0, _lib.transformTSToJS)(outputPath, template);
  }
  return fileList;
};

// add routes for all pages
const routes = async ({
  model: name,
  path: scaffoldPath = '',
  nestScaffoldByModel
}) => {
  var _context15;
  if (typeof nestScaffoldByModel === 'undefined') {
    nestScaffoldByModel = (0, _projectConfig.getConfig)().generate.nestScaffoldByModel;
  }
  const templateNames = getTemplateStrings(name, scaffoldPath);
  const nameVars = (0, _lib.nameVariants)(name);
  const model = await (0, _schemaHelpers.getSchema)(nameVars.singularPascalName);
  const idRouteParam = getIdType(model) === 'Int' ? ':Int' : '';
  const idName = getIdName(model);
  const paramScaffoldPath = scaffoldPath === '' ? scaffoldPath : (0, _map.default)(_context15 = scaffoldPath.split('/')).call(_context15, _paramCase.paramCase).join('/') + '/';
  const pascalScaffoldPath = (0, _pascalcase.default)(scaffoldPath);
  const pageRoot = pascalScaffoldPath + (nestScaffoldByModel ? nameVars.singularPascalName : '');
  return [
  // new
  `<Route path="/${paramScaffoldPath}${nameVars.pluralParamName}/new" page={${pageRoot}New${nameVars.singularPascalName}Page} name="${templateNames.newRouteName}" />`,
  // edit
  `<Route path="/${paramScaffoldPath}${nameVars.pluralParamName}/{${idName}${idRouteParam}}/edit" page={${pageRoot}Edit${nameVars.singularPascalName}Page} name="${templateNames.editRouteName}" />`,
  // singular
  `<Route path="/${paramScaffoldPath}${nameVars.pluralParamName}/{${idName}${idRouteParam}}" page={${pageRoot}${nameVars.singularPascalName}Page} name="${templateNames.singularRouteName}" />`,
  // plural
  `<Route path="/${paramScaffoldPath}${nameVars.pluralParamName}" page={${pageRoot}${nameVars.pluralPascalName}Page} name="${templateNames.pluralRouteName}" />`];
};
exports.routes = routes;
const addLayoutImport = () => {
  const importLayout = `import ScaffoldLayout from 'src/layouts/ScaffoldLayout'`;
  const routesPath = (0, _lib.getPaths)().web.routes;
  const routesContent = (0, _lib.readFile)(routesPath).toString();
  if (!routesContent.match(importLayout)) {
    const newRoutesContent = routesContent.replace(/['"]@redwoodjs\/router['"](\s*)/, `'@redwoodjs/router'\n\n${importLayout}$1`);
    (0, _lib.writeFile)(routesPath, newRoutesContent, {
      overwriteExisting: true
    });
    return 'Added layout import to Routes.{jsx,tsx}';
  } else {
    return 'Layout import already exists in Routes.{jsx,tsx}';
  }
};
const addHelperPackages = async task => {
  const packageJsonPath = _path.default.join((0, _lib.getPaths)().web.base, 'package.json');
  const packageJson = require(packageJsonPath);

  // Skip if humanize-string is already installed
  if (packageJson.dependencies['humanize-string']) {
    return task.skip('Skipping. Already installed');
  }

  // Has to be v2.1.0 because v3 switched to ESM module format, which we don't
  // support yet (2022-09-20)
  // TODO: Update to latest version when RW supports ESMs
  await (0, _execa.default)('yarn', ['workspace', 'web', 'add', 'humanize-string@2.1.0']);
  (0, _rollback.addFunctionToRollback)(async () => {
    await (0, _execa.default)('yarn', ['workspace', 'web', 'remove', 'humanize-string']);
  });
};
const addSetImport = task => {
  const routesPath = (0, _lib.getPaths)().web.routes;
  const routesContent = (0, _lib.readFile)(routesPath).toString();
  const [redwoodRouterImport, importStart, spacing, importContent, importEnd] = routesContent.match(/(import {)(\s*)([^]*)(} from ['"]@redwoodjs\/router['"])/) || [];
  if (!redwoodRouterImport) {
    task.skip("Couldn't add Set import from @redwoodjs/router to Routes.{jsx,tsx}");
    return undefined;
  }
  const routerImports = importContent.replace(/\s/g, '').split(',');
  if ((0, _includes.default)(routerImports).call(routerImports, PACKAGE_SET)) {
    return 'Skipping Set import';
  }
  const newRoutesContent = routesContent.replace(redwoodRouterImport, importStart + spacing + PACKAGE_SET + `,` + spacing + importContent + importEnd);
  (0, _lib.writeFile)(routesPath, newRoutesContent, {
    overwriteExisting: true
  });
  return 'Added Set import to Routes.{jsx,tsx}';
};
const addScaffoldSetToRouter = async (model, path) => {
  const templateNames = getTemplateStrings(model, path);
  const nameVars = (0, _lib.nameVariants)(model);
  const title = nameVars.pluralPascalName;
  const titleTo = templateNames.pluralRouteName;
  const buttonLabel = `New ${nameVars.singularPascalName}`;
  const buttonTo = templateNames.newRouteName;
  return (0, _lib.addRoutesToRouterTask)(await routes({
    model,
    path
  }), 'ScaffoldLayout', {
    title,
    titleTo,
    buttonLabel,
    buttonTo
  });
};
const command = exports.command = 'scaffold <model>';
const description = exports.description = 'Generate Pages, SDL, and Services files based on a given DB schema Model. Also accepts <path/model>';
const builder = yargs => {
  var _context16;
  yargs.positional('model', {
    description: "Model to scaffold. You can also use <path/model> to nest files by type at the given path directory (or directories). For example, 'rw g scaffold admin/post'"
  }).option('docs', {
    description: 'Generate SDL and GraphQL comments to use in documentation',
    type: 'boolean',
    default: false
  }).option('tests', {
    description: 'Generate test files',
    type: 'boolean'
  }).option('tailwind', {
    description: 'Generate TailwindCSS version of scaffold.css (automatically set to `true` if TailwindCSS config exists)',
    type: 'boolean'
  }).option('rollback', {
    description: 'Revert all generator actions if an error occurs',
    type: 'boolean',
    default: true
  }).epilogue(`Also see the ${(0, _terminalLink.default)('Redwood CLI Reference', 'https://redwoodjs.com/docs/cli-commands#generate-scaffold')}`);

  // Merge generator defaults in
  (0, _forEach.default)(_context16 = (0, _entries.default)(_helpers.yargsDefaults)).call(_context16, ([option, config]) => {
    yargs.option(option, config);
  });
};
exports.builder = builder;
const tasks = ({
  docs,
  model,
  path,
  force,
  tests,
  typescript,
  javascript,
  tailwind
}) => {
  return new _listr.Listr([{
    title: 'Generating scaffold files...',
    task: async () => {
      const f = await files({
        docs,
        model,
        path,
        tests,
        typescript,
        javascript,
        tailwind,
        force
      });
      return (0, _lib.writeFilesTask)(f, {
        overwriteExisting: force
      });
    }
  }, {
    title: 'Install helper packages',
    task: (_, task) => addHelperPackages(task)
  }, {
    title: 'Adding layout import...',
    task: async () => addLayoutImport()
  }, {
    title: 'Adding set import...',
    task: async (_, task) => addSetImport(task)
  }, {
    title: 'Adding scaffold routes...',
    task: async () => addScaffoldSetToRouter(model, path)
  }, {
    title: 'Adding scaffold asset imports...',
    task: () => (0, _lib.addScaffoldImport)()
  }, {
    title: `Generating types ...`,
    task: async () => {
      const {
        errors
      } = await (0, _generate.generate)();
      for (const {
        message,
        error
      } of errors) {
        console.error(message);
        console.log();
        console.error(error);
        console.log();
      }
      (0, _rollback.addFunctionToRollback)(_generate.generate, true);
    }
  }], {
    rendererOptions: {
      collapseSubtasks: false
    },
    exitOnError: true
  });
};
exports.tasks = tasks;
const handler = async ({
  model: modelArg,
  force,
  tests,
  typescript,
  tailwind,
  docs = false,
  rollback
}) => {
  if (tests === undefined) {
    tests = (0, _projectConfig.getConfig)().generate.tests;
  }
  (0, _cliHelpers.recordTelemetryAttributes)({
    command: 'generate scaffold',
    force,
    tests,
    typescript,
    tailwind,
    docs,
    rollback
  });
  const {
    model,
    path
  } = splitPathAndModel(modelArg);
  tailwind = shouldUseTailwindCSS(tailwind);
  try {
    const {
      name
    } = await (0, _schemaHelpers.verifyModelName)({
      name: model
    });
    const t = tasks({
      docs,
      model: name,
      path,
      force,
      tests,
      typescript,
      tailwind
    });
    if (rollback && !force) {
      (0, _rollback.prepareForRollback)(t);
    }
    await t.run();
  } catch (e) {
    console.log(_colors.default.error(e.message));
    process.exit(e?.existCode || 1);
  }
};
exports.handler = handler;
const splitPathAndModel = pathSlashModel => {
  var _context17;
  const path = (0, _slice.default)(_context17 = pathSlashModel.split('/')).call(_context17, 0, -1).join('/');
  // This code will work whether or not there's a path in model
  // E.g. if model is just 'post',
  // path.split('/') will return ['post'].
  const model = pathSlashModel.split('/').pop();
  return {
    model,
    path
  };
};
exports.splitPathAndModel = splitPathAndModel;